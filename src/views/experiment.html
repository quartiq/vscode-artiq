<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Experiment</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="{TABULATOR_STYLES_URI}" rel="stylesheet">
    <link href="{CUSTOM_STYLES_URI}" rel="stylesheet">
    <script type="text/javascript" src="{TABULATOR_SCRIPT_URI}"></script>

    <style>
        .hidden { display: none }
    </style>
</head>

<body>
    <div class="idle hidden">
        <p class="msg select">Select an experiment in the editor or in the explorer ...</p>
        <p class="msg scan">Unknown experiment. Consider saving the file and rescanning the repository ...</p>
        <p class="msg examine">Unknown experiment. Consider saving and examining the file ...</p>
    </div>

    <div class="table"></div>

    <script type="module">
        // TODO: unify experiments and arguments
        import {logging, nowsecs} from "{SHARED_URI}/utils.js";
        import {entry} from "{SHARED_URI}/entries.js";
        const vscode = acquireVsCodeApi();
        let table;

        let idleel = document.querySelector(".idle");
        let msgels = idleel.querySelectorAll(".msg");
        let tableel = document.querySelector(".table");

        let fields = {
            "Priority": { key: "priority", procdesc: { ty: "StringValue" }},
            "Log level": { key: "log_level", procdesc: { ty: "EnumerationValue", choices: Object.keys(logging) }},
            "Pipeline": { key: "pipeline_name", procdesc: { ty: "StringValue" }},
            "Due date": { key: "due_date", procdesc: { ty: "UnixtimeValue" }},
            "Flush": { key: "flush", procdesc: { ty: "BooleanValue" }},
        };

        let editor = (cell, onRendered, success, cancel) => {
            let procdesc = cell.getRow().getData().procdesc;
            return entry(procdesc.ty)?.editor({procdesc, cell, onRendered, success, cancel, post: vscode.postMessage});
        };

        let cellEdited = cell => {
            let raw = cell.getRow().getData();
            vscode.postMessage({
                action: "change", data: {
                    key: fields[raw.name].key,
                    value: raw.state,
                },
            });
        };

        let formatter = cell => {
            let data = cell.getRow().getData();
            if (data.name !== "Due date") return data.state;
            return (new Date(data.state * 1000)).toLocaleString();
        };

        let mutator = (value, data) => data.name === "Due date" && value === null ? nowsecs() : value;

        let updateTable = exp => {
            let data = Object.entries(fields)
                .map(([name, field]) => ({ name, procdesc: field.procdesc, state: exp[field.key] }));

            table?.destroy?.();
            table = new Tabulator(".table", {
                headerVisible: false,
                layout: "fitDataFill",
                data,
                columns: [
                    { field: "name" },
                    { field: "state", editor, cellEdited, formatter, mutator },
                ],
            });
        };

        let actions = {
            update: data => {
                if (!data.selectedClass) {
                    showIdle("select");
                    return;
                }

                if (!data.exp && data.inRepo) {
                    showIdle("scan");
                    return;
                }

                if (!data.exp) {
                    showIdle("examine");
                    return;
                }

                updateTable(data.exp);
                idleel.classList.add("hidden");
                tableel.classList.remove("hidden");
            }
        };

        let showIdle = type => {
            msgels.forEach(el => el.classList.add("hidden"));
            idleel.querySelector(`.msg.${type}`).classList.remove("hidden");

            idleel.classList.remove("hidden");
            tableel.classList.add("hidden");
        };

        window.addEventListener("message", ev => actions[ev.data.action](ev.data.data));
    </script>
</body>

</html>